---
title: 游戏中菜单内有可操作的通知系统

date: 2017-05-24 19:54:42

categories: "Unity脚本"
tags:
       - Unity
description: 如果策划要求游戏中菜单的按钮（某一界面的接口）需要给出打开界面有多少可操作的提示。
---


## 问题描述

    如果策划要求游戏中菜单的按钮（某一界面的接口）需要给出打开界面有多少可操作的提示。如下图中红圈所示：

![图](游戏中菜单内有可操作的通知系统
/1.jpg)

## 解决方案
  
  每个界面有多个提示， 每个提示由 背景、数字(1 - 9)、感叹号(!)组成，在每个界面中添加下面的脚本对此进行处理。

观察者

```bash
//抽象基类
public abstract class Observe<T> : MonoBehaviour
{
    public abstract T Key { get; set; }
    public abstract void SetNotifications(subjectData data);

    public abstract void SetOneNotification(int buttonID, int iconValue);
    public abstract int GetCount();
}
```

```bash
public class NotificationObserve : Observe<ObserveKey>
{
    [SerializeField]
    protected UISprite[] iconBackgrounds;
    [SerializeField]
    protected UILabel[] iconLabels;
    [SerializeField]
    protected UISprite[] iconExclamations;

    public override ObserveKey Key
    {
        get
        {
            throw new NotImplementedException();
        }
        set
        {
            throw new NotImplementedException();
        }
    }

    void Start()
    {
        Key = ObserveKey.mainUI;
        NotificationSubject.Instance.RigesterObserve(this);
    }

    public override void SetNotifications(subjectData data)
    {
        for(var i = 0; i < data.nums.Length; ++i)
        {
            SetOneNotification(i, data.nums[i]);
        }
    }

    public override void SetOneNotification(int buttonID, int iconValue)
    {
        if (iconValue < 0)	
        {
            iconBackgrounds[buttonID].enabled = false;
            iconLabels[buttonID].enabled = false;
            iconExclamations[buttonID].enabled = false;
        }
        else if (iconValue == 0 || iconValue > 9)
        {
            iconBackgrounds[buttonID].enabled = true;
            iconLabels[buttonID].enabled = false;	
            iconExclamations[buttonID].enabled = true;
        }
        else if (iconValue > 0)
        {
            iconBackgrounds[buttonID].enabled = true;
            iconLabels[buttonID].enabled = true;
            iconLabels[buttonID].text = (Math.Min(iconValue, 9)).ToString();
            iconExclamations[buttonID].enabled = false;
        }
    }

    public override int GetCount()
    {
        return iconBackgrounds.Length;
    }
}

```

主题

```bash
///每个界面对应的关键字
public enum ObserveKey
{
    mainUI,
    storeUI,
    none
}
///每个界面的通知数据
public class subjectData
{
    public ObserveKey key;
    public int[] nums;

    public subjectData(ObserveKey key, int[] nums)
    {
        this.key = key;
        this.nums = nums;
    }

    public string ToJson()
    {
        return "";
    }

    public bool Parse(string json)
    {
        return true;
    }
}
///抽象基类
public abstract class Subject<T> : MonoBehaviour
{
    protected Dictionary<T, Observe<T>> observes = new Dictionary<T, Observe<T>>();
    public void RigesterObserve(Observe<T> observe)
     {
         if (!observes.ContainsKey(observe.Key))
             observes.Add(observe.Key, observe);
     }

    public void UnRigesterObserve(Observe<T> observe)
     {
         if (observes.ContainsKey(observe.Key))
             observes.Remove(observe.Key);
     }
    public Observe<T> GetObserve(T key)
     {
         if (observes.ContainsKey(key))
             return observes[key];
         return null;
     }
     public abstract void Notify(); ///通知所有的界面

     public abstract void NotifyOneKey(T key);///通知key对应的界面

     public abstract void NotifyOneOne(T key, int index);///通知key对应界面的对应编号
}
```
```bash
///通知的管理类
public class NotificationSubject : Subject<ObserveKey>
{
    public subjectData[] datas;
    public static NotificationSubject Instance;
    void Awake()
    {
        datas = new subjectData[(int)ObserveKey.none];
        for (int i = (int)ObserveKey.none; i >= 0; --i)
        {
            datas[i].key = (ObserveKey)i;
            datas[i].nums = new int[base.GetObserve(datas[i].key).GetCount()];
        }
    }

    public override void Notify()
    {
         this.CalcDatas();

         for(int i = (int)ObserveKey.none; i >= 0; --i)
         {
             observes[(ObserveKey)i].SetNotifications(datas[i]);
         }
    }

    public override void NotifyOneKey(ObserveKey key)
    {
        this.CalcDatas();

        observes[key].SetNotifications(datas[(int)key]);
    }

    public override void NotifyOneOne(ObserveKey key, int index)
    {
        this.CalcDatas();

        observes[key].SetOneNotification(index, datas[(int)key].nums[index]);
    }

    /// <summary>
    /// 计算subjectData中nums值
    /// </summary>
    public void CalcDatas()
    {

    }
}			
```

当需要时调用NotificationSubject.Instance.Notify / NotifyOneKey / NotifyOneOne即可。